'''
- TL : 1s
- 1<=N<=100
- 계단수 : 인접한 모든 자리의 차이가 1인 수 , 0으로 시작하는 수는 아님
첫째 줄에 길이가 N인 계단 수의 갯수를 1_000_000_000 으로 나눈 나머지를 출력
>>> 예상 분류 : 문자열
>>> 길이가 1인 계단수 : 1,2,3,4,5,6,7,8,9 -> 총 9개
>>> 길이가 2인 계단수 : 10, 12, 
                    21, 23, 
                    32, 34, 
                    43, 45, 
                    54, 56, 
                    65, 67, 
                    76, 78, 
                    87, 89, 
                    98 -> 총 17개
1
 ,0
   ,1
     ,0
       ,1
     ,2
       ,1
       ,3
       
 ,2
   ,1
     ,0
       ,1
     ,2
       ,1
       ,3
       
   ,3
     ,2
       ,1
       ,3
       
       
     ,4
       ,3
       ,5
-> 1시작 : 1,2,3,6,10,20,35 ...

9
 ,8
   ,7
     ,6
       ,5
       ,7
     ,8
       ,7
       ,9
   ,9
     ,8
       ,7
       ,9
-> 9시작 : 1,1,2,3,6

1. 문자열 구현
    - i+1번째 문자열 = (i번째 문자열) +- 1 
    - 9로 시작하는 부분만 예외처리 해주면 됨
    - 시작수:다음갯수 = 1:2개, 2:2개, ..., 9:1개
    - 갯수 = (1번시작)*1*2*1... + (0번쨰 자리 가능수)*(2)*(2)*...(2) + (9번시작)*(1)*(2)*(1)..
          = 2**((n-1)%2) + (7)*(2**n-1) + 2**((n-1)//2)
    >>> 특별한 공식이 없어서 dfs로 풀어야 할 듯

2. dfs
    >>> 시간,메모리가 대략 O(2**n)이므로 TLE,MLE 발생
    
3. dfs (메모이제이션) -> dp (reference : https://cotak.tistory.com/12)
    - dp[자리수][현재숫자] = dp[자리수-1][현재숫자-1, 현재숫자+1]
      dp[n][i] = dp[n-1][i +- 1]
        - i == 0
        : dp[n][0] = dp[n-1][1] (-1은 안되므로 1만)
        - i == 1~8
        : dp[n][i] = dp[n][i-1]+ dp[n-1][i+1]
        - i == 9
        : dp[n][9] = dp[n-1][8] (8일때만 9가 가능)
'''

# i=1~9까지 계산
def solution(n):
    global dp
    DIVISOR = 1_000_000_000
    # dp생성
    dp = [[0]*10 for _ in range(n+1)]
    
    # 자릿수 == 1일때를 초기화해줌
    for i in range(1,10):
        dp[1][i] = 1
        
    # 자리수 == 2~9일때를 계산
    for i in range(2,n+1):
        for j in range(10):
            # 현재 수가 0일때
            if j == 0:
                dp[i][j] = dp[i-1][1]
            # 현재 수가 9일때
            elif j == 9:
                dp[i][j] = dp[i-1][8]
            # 현재 수가 2~8일때
            else:
                dp[i][j] = dp[i-1][j+1] + dp[i-1][j-1]
                
    # 1~9일때를 모두 더한게 정답
    answer = sum(dp[n])
    return answer % DIVISOR

print(solution(int(input())))